// COPYRIGHT (C) HARRY CLARK 2025
// LIGHTWEIGHT, VERSATILE Z80 EMULATOR

// THIS FILE PERTAINS TOWARDS THE MAIN FUNCTIONALITY ENCOMPASSING THE OPCODES

// NESTED INCLUDES

#include "z80OPCODE.h"

#ifdef BUILD_OP_TABLE

#define         Z80_OPCODE_MASK     0xC0
#define         Z80_OPCODE_PATTERN  0x40


// THE FOLLOWING IMPLEMENTS A SIMILAR, IF NOT, THE EXACT SAME SCHEMA DEFINED IN LIB68K
// WHEREBY, A MACRO ENCOMPASSES THE CREATION OF OPCODES ACROSS ALL FILES

// SUCH THAT IT IS MODULAR ENOUGH TO BE INCLUDED ELSEWHERE WITHOUT THE NEED FOR REIMPLEMENTATION

// SEE z80OCODE.h FOR IMPLEMENTATION

//========================================================================
//                  Z80 STACK MANAGEMENT FUNCTIONS
//========================================================================

Z80_MAKE_OPCODE(PUSH)
{
    Z->SP -= 2;
    Z80_WRITE_WORD(Z->Z80_MEM, Z->SP, VALUE);
}

Z80_MAKE_OPCODE_16(POP)
{
    const U16 RESULT = Z80_READ_WORD(Z->Z80_MEM, Z->SP - 2);
    Z->SP += 2;

    return RESULT;
}

Z80_MAKE_OPCODE_8(NEXTB)
{
    return Z80_READ_BYTE(Z->Z80_MEM, Z->PC++);
}

Z80_MAKE_OPCODE_16(NEXTW)
{
    return Z80_READ_WORD(Z->Z80_MEM, Z->PC - 2);
}

Z80_MAKE_OPCODE(ADD)
{
    U8 RESULT = Z80_A + VALUE;

    Z->FLAGS.FLAG_C = (Z80_A + VALUE) > 0xFF;
    Z->FLAGS.FLAG_N = 0;
    Z->FLAGS.FLAG_P = CALC_VFLAG_8(Z80_A, VALUE, RESULT);
    Z->FLAGS.FLAG_B3 = IS_BIT_SET(RESULT, 3);
    Z->FLAGS.FLAG_B5 = IS_BIT_SET(RESULT, 5);
    Z->FLAGS.FLAG_Z = RESULT == 0;
    Z->FLAGS.FLAG_S = RESULT >> 7;

    RESULT = (Z80_GET_REGISTERS(Z, Z80_A) << 8);
}

Z80_MAKE_OPCODE(ADD_R)
{
    U8 RESULT = Z80_GET_REGISTERS(Z, Z80_A) + VALUE;

    Z->FLAGS.FLAG_C = (Z80_GET_REGISTERS(Z, Z80_A) + VALUE) > 0xFF;
    Z->FLAGS.FLAG_N = 0;
    Z->FLAGS.FLAG_P = PARTIY(RESULT);
    Z->FLAGS.FLAG_H = (Z80_GET_REGISTERS(Z, Z80_A) & 0x0F) + (VALUE & 0x0F) > 0x0F;
    Z->FLAGS.FLAG_B3 = IS_BIT_SET(RESULT, 3);
    Z->FLAGS.FLAG_B5 = IS_BIT_SET(RESULT, 5);
    Z->FLAGS.FLAG_Z = RESULT == 0;
    Z->FLAGS.FLAG_S = RESULT >> 7;

    Z80_GET_REGISTERS(Z, RESULT);
}

Z80_MAKE_OPCODE(ADD_IMM)
{
    ADD(Z, Z->Z80_MEM->READ_8((void*)(unsigned)Z->PC, VALUE));
}

Z80_MAKE_OPCODE(AND)
{
    U8 RESULT = Z80_GET_REGISTERS(Z, Z80_A) & VALUE;

    Z->FLAGS.FLAG_C = 0;
    Z->FLAGS.FLAG_N = 0;
    Z->FLAGS.FLAG_P = PARTIY(RESULT);
    Z->FLAGS.FLAG_H = 1;
    Z->FLAGS.FLAG_B3 = IS_BIT_SET(RESULT, 3);
    Z->FLAGS.FLAG_B5 = IS_BIT_SET(RESULT, 5);
    Z->FLAGS.FLAG_Z = RESULT == 0;
    Z->FLAGS.FLAG_S = RESULT >> 7;

    Z80_GET_REGISTERS(Z, RESULT);
}

Z80_MAKE_OPCODE(AND_IMM)
{
    AND(Z, Z->Z80_MEM->READ_8((void*)(unsigned)Z->PC, VALUE));
}

Z80_MAKE_OPCODE(AND_R)
{
    AND(Z, Z->Z80_MEM->READ_8((void*)(unsigned)Z->PC, VALUE));
}

Z80_MAKE_OPCODE(ADC)
{
    ADD(Z, VALUE + Z->FLAGS.FLAG_C);
}

Z80_MAKE_OPCODE(ADC_R)
{
    ADC(Z, Z->Z80_MEM->READ_8((void*)(unsigned)Z->PC, VALUE));
}

Z80_MAKE_OPCODE(ADC_HL)
{
    VALUE += Z->FLAGS.FLAG_C;

    U16 H1 = Z80_H;
    U16 RESULT = H1 + VALUE;

    Z->FLAGS.FLAG_C = (VALUE + H1) > 0xFFFF;
    Z->FLAGS.FLAG_N = 0;
    Z->FLAGS.FLAG_P = CALC_VFLAG_16(H1, VALUE, RESULT);
    Z->FLAGS.FLAG_H = ((H1 & 0xFF) + (VALUE & 0xFFF)) > 0xFFFF;
    Z->FLAGS.FLAG_B3 = IS_BIT_SET(RESULT >> 8, 3);
    Z->FLAGS.FLAG_B5 = IS_BIT_SET(RESULT >> 8, 5);
    Z->FLAGS.FLAG_Z = 0;
    Z->FLAGS.FLAG_S = RESULT >> 15;

    Z80_SET_PAIR(Z, Z80_H, Z80_L, RESULT);
}

Z80_MAKE_OPCODE(ADC_IMM)
{
    ADC(Z, Z->Z80_MEM->READ_8((void*)(unsigned)Z->PC, VALUE));
    Z->PC++;
}

Z80_MAKE_OPCODE(BIT)
{
    U8 BIT = 0;
    U8 RESULT = VALUE & BIT;

    Z->FLAGS.FLAG_N = 0;
    Z->FLAGS.FLAG_P = 0;
    Z->FLAGS.FLAG_H = 1;
    Z->FLAGS.FLAG_B3 = IS_BIT_SET(VALUE, 3);
    Z->FLAGS.FLAG_B5 = IS_BIT_SET(VALUE, 5);
    Z->FLAGS.FLAG_Z = RESULT = 0;
    Z->FLAGS.FLAG_S = RESULT >> 7;
}

Z80_MAKE_OPCODE(CALL)
{ 
    U16 READ_VALUE = Z80_READ_WORD(Z->Z80_MEM, VALUE);
    PUSH(Z, Z->PC + 2);

    Z->PC = READ_VALUE;
}

Z80_MAKE_OPCODE(CALL_COND)
{
    bool COND = false;

    if(COND) { CALL(Z, VALUE); Z->CYCLES += 7; }
    else { Z->PC += 2; }
}

Z80_MAKE_OPCODE(CCF)
{
    Z->FLAGS.FLAG_H = Z->FLAGS.FLAG_C;
    Z->FLAGS.FLAG_C = !Z->FLAGS.FLAG_C;
    Z->FLAGS.FLAG_N = VALUE;
    Z->FLAGS.FLAG_B3 = IS_BIT_SET(Z80_GET_REGISTERS(Z, Z80_A), 3);
    Z->FLAGS.FLAG_B5 = IS_BIT_SET(Z80_GET_REGISTERS(Z, Z80_A), 5);
}

// A PROFICIENT WAY OF BEING ABLE TO ACCES THE OPCODE MASK TTPES
// BASED ON THE MAJORITY OF INSTRUCTIONS, IMM LOADS AND NOP/ILLEGAL

U8 Z80_GET_OPCODE_CYCLES(U8 OPCODE)
{
    U8 PREFIX = 0;

    switch (PREFIX)
    {
        case 0xED:
            return ((OPCODE & Z80_OPCODE_MASK) == Z80_OPCODE_PATTERN) ? 0x0C : 0x08;

        case 0xDD:
        case 0xFD:
            return ((OPCODE & Z80_OPCODE_MASK) == Z80_OPCODE_PATTERN) ? 0x13 : 0x04;
    
        default:
            return (OPCODE & Z80_OPCODE_MASK) ? 0x06 : ((OPCODE & 0xC7) == 0x06) ? 0x07 : 0x04;   
    }
}

void Z80_EXEC(CPU_Z80* const Z80, U8 OPCODE)
{
    Z80->CYCLES += Z80_GET_OPCODE_CYCLES(OPCODE);
}

#endif
